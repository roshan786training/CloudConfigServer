1) Create a new project - Message Service, which returns appropriate greeting messages based on user input.
For E.g. if user input = 1, message returned  Good Morning, user input = 2, message returned  Good Afternoon.
Hint : Create Message Rest Controller, that accepts the input and returns the String response.

2) Create a new Project Display Service, which acts as client to 'Message Service' and returns string response to client generated by 'Message Service'



Spring Cloud
Spring Cloud is a project that provides tools for developers to quickly build some of the common patterns needed in distributed systems. 

Pattern1 - Service Discovery. 
Pattern2 - Distributed Configuration Management. 
Pattern3 - Circuit Breakers. 
Pattern4 - Routing and cross cutting concerns. 
Pattern5 - Control Bus.

.. so on


In micro-services Architecture, as there are multiple services running, we need to communicate with each 
other very frequently and this is typically done via rest call which can be done via rest template.

But in RestTemplate, we must be specifying ip address and port. Also, every time we need to make a call, we need
to make an object of RestTemplate. This is time consuming and error prone.

To Simplify this,we have OpenFeign.

OpenFeign:
OpenFeign makes rest call declarative. 
This is done by dynamically implementing interface [This is done using JDK dynamic proxies - Proxy design pattern]

Steps:

1. Add appropriate dependency.
  <dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-openfeign</artifactId>
 </dependency>
2. Create an interface.
3. Annotate this interface with @FeignClient
4. Add Appropriate attributes to this annotation - url(server address) and value(service name).
5. Declare methods with exact same signature we want to call using rest api.[method name can be anything]. 
6. Enable Feign client by writing following annotation on top of main method - @EnableFeignClients
7. Autowire FeignClient at appropriate class.

Service Discovery-

It is very common in micro service architecture to have multiple instances of the same service running at a time. 
It is also very common that, a few instances of a specific micro service are killed at runtime or few more instances are spinned up at runtime of 
that micro service. 

This is done to save the resources or if there is a huge load to cater multiple clients. 

Because this is happening at runtime it is impossible to know it in advance which port is being assigned to which instance and hence,
communication among micro servers cannot be done using port numbers. 

To exactly solve this problem, we have a pattern in micro services known as Service Discovery [It is a service registry].

The idea of service registry and discovery is each instance of micro-service registers itself with service registry using a unique name. 
Consumers of micro-service needs to know only the unique name of micro-service which it needs to call. 

Implementation of this service discovery is given by Netflix - Eureka . 

Steps to Create Eureka Server- 
1. Create a new SpringBoot project with appropriate dependency. 
2. Annotate Application Class with @EnableEurekaServer . 
3. Change the port to 8761 [not mandate but strongly recommended]
4. Test it . To Test , Go to browser and type http://localhost:8761

Steps to Create Eureka Client-
1. Add appropriate dependency.
Every Eureka Client assumes following property if not configured explicitly-

eureka.client.service-url.defaultZone = http://localhost:8761/eureka

2. Annotate Application class with @EnableEurekaClient [not mandate but recommended]

3. Every Eureka server is eureka client also and hence it register itself with Eureka. 
we donot want this to happen So, Add the following properties to application properties of Eureka Server- 

eureka.client.fetch-registry=false
eureka.client.register-with-eureka=false

------------------------------------------------

Api Gateway - Api Gateway is used for routing the request. Also, to do some pre and post processing .
The idea is MicroServices shouldnot be talking to each other directly. They must be making the call via Api Gateway . Also, Client will be talking to 
micro services via Api Gateway.

We will be exposing port of only Api gateway to outside world. Typically, Api Gateway runs on port
80.

Steps for Api Gateway - 
1. Create a Separate Spring Boot Application .
2. Add Appropriate dependency. 

 <dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-gateway</artifactId>
 </dependency>
 <dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
 </dependency>

3. Add Appropriate properties. application.properties looks like below- 

 server.port=80
 spring.application.name=apigateway
 eureka.client.service-url.defaultZone=http://localhost:8761/eureka
 #Following property allows api gateway to find microservice using it's name as it is registered
 #with Eureka
 spring.cloud.gateway.discovery.locator.enabled=true
 #Following property allows api-gateway to find microservice names in lower-case.
 #If we see Eureka server dashboard, it's in upper case.
 spring.cloud.gateway.discovery.locator.lower-case-service-id=true

----------------------

Steps for Circuit Breaker- 
1. Add appropriate dependencies. 
 <dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>
   spring-cloud-starter-circuitbreaker-resilience4j
  </artifactId>
 </dependency>

2. Add appropriate properties:
 server.port=8083
 spring.application.name=displayservice
 #This property decides how many last calls to consider for remote microservice is availble or not 
 resilience4j.circuitbreaker.instances.ms.sliding-window-size=4
 #Following property tells how much % of calls of last number of calls configured to decide 
 #whether remote micro-service is available or not 
 resilience4j.circuitbreaker.instances.ms.failure-rate-threshold=50
 #Following property tell how much time switch to remain in open state before going to half open state
 #During this time, the circuit is open : no calls are made to remote-microservice . 
 resilience4j.circuitbreaker.instances.ms.wait-duration-in-open-state=1m
 #Following property tells after the wait time , whether we want to move from open to half-open circuit
 resilience4j.circuitbreaker.instances.ms.automatic-transition-from-open-to-half-open-enabled=true
 #Following property tells how many calls to remote service should be made in half-open state
 resilience4j.circuitbreaker.instances.ms.permitted-number-of-calls-in-half-open-state=2

3. Write fall-back method 
 This method is responsible for giving default response when the circuit is open. 
 Fallback method signature must exactly match to the remote method signature. In addition to
 that, It must have 1 argument of type Throwable. 
 
4. Annotate method which is making rest call with @CircuitBreaker 
 @CircuitBreaker(name="ms",fallbackMethod="handleFailureFromGreetingsService") -> This name
  is in application.properties.we can name it anything but then modify application.properties accordingly.

------------------------------

Cloud Config Server
In monolithic application, we just have one atabase, maintaining complete data for all the modules, such dbs are called as integration database.
In microservice arc, every microservice has its own database
configuring such thing for each microservice is time consuming task
For e.g. we have different db config for different env, such as dev env, qa env and prod env.
Everytime to make such changes, opening application properties for such changes is difficult job, hence we want to maintain usch config info for all microservices centrally anetch such info at run time. this is done using CLoud Cnfig server
By default Cloud Config Server assumes the central repo is Git repository, though it can be configured through a local location on the host machine.
Inorder to change this add following properties in appliation.properties of Cloud Config Server.
	#spring.cloud.config.server.git.uri=https://github.com/roshan786training/CloudConfigServer
	spring.profiles.active=native
	spring.cloud.config.server.native.search-locations=file:C:\\MyRepo

Steps to config, cloud config server
1) Create new springboot project
2) add appropriate dependecies
	
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-config-server</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
3) annotate application class with @EnableConfigServer
4) Change port to 8888
5) Add appropriate properties in application.properties file
	application.properties
	server.port=8888
	spring.application.name=configserver
	spring.cloud.config.server.git.uri=https://github.com/roshan786training/CloudConfigServer




http://localhost:8888/application/default -- this is REST endpoint exposed by Cloud config Server

--------------------------------------------------------

Steps for Cloud Config Client
1) Add appropriate dependecies in each microservice
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>
				spring-cloud-starter-netflix-eureka-server
			</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-config</artifactId>
		</dependency>
2) Add appropriate property
	spring.config.import=optional:configserver:http://localhost:8888

Once the micro service has picked up the config information from the config server, any changes made to configuration after that wont be reflected in the running microservices.
In order for Microservices to pick up the changes at runtime, we need to carry out the following steps:
1) Add actuator depency in each microservice 
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency
2) Enabled refresh endpoint by adding the folowing property in all microservices
	management.endpoint.web.exposure.include=refresh
3) Make POST request to refresh endpoint
	http://localhost/messageservice/actuator/refresh
4) Annotate the main class with @RefreshScope where we are reading the values from central config



Feedback
-------------------------------------------------------------------------
https://feedbackally.walmart.com/survey/KOCTfESK3JCv3W0


Post Test link
------------------------------------------------------------------------
https://docs.google.com/forms/d/e/1FAIpQLSdl5UIyoIxZsKF_kb6564ZATFzTVTG6Ffx6aWPDhnJiNSMSHA/viewform


www.linkedin.com/in/sandeep-chatuphale
